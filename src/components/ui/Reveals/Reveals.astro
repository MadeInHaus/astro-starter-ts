---
import './Reveals.css';
---

<script>
    import type { SplitOptions } from '@/utils/splitter/types';
    import { split } from '@/utils/splitter';
    import { isPartiallyInViewport } from '@/utils';
    import { moveAttributes, moveChildNodes } from '@/utils/splitter/dom';

    class RevealController {
        private revealElements: RevealElement[] = [];
        private kerningCache: Map<string, number> = new Map();

        constructor() {
            document.addEventListener('astro:before-swap', this.beforeSwapHandler.bind(this));
            document.addEventListener('astro:after-swap', this.afterSwapHandler.bind(this));
            this.initialize();
        }

        private beforeSwapHandler() {
            this.destroy();
        }

        private afterSwapHandler() {
            this.initialize();
        }

        private initialize() {
            const splitOptions: Required<SplitOptions> = {
                whitelistSelectors: ['img', 'svg'],
                graphemeSplitter: (str: string) => [...str.normalize('NFC')],
                kerningCache: this.kerningCache,
                kerningCacheKey: (a: string, b: string) => `${a}-${b}`,
                doubleWrap: 'lines',
                splitLines: true,
                fixKerning: true,
                debug: false,
            };
            this.revealElements = [...document.querySelectorAll('h1, h2, [data-reveal]')]
                .filter(element => element instanceof HTMLElement)
                .filter(element => element.dataset.reveal !== 'none')
                .map(element => {
                    const type = element.matches('h1, h2, [data-reveal="lines"]')
                        ? 'lines'
                        : 'block';
                    return new RevealElement({ type, element, splitOptions });
                });
            this.revealElements.forEach(instance => instance.init());
        }

        private destroy() {
            this.revealElements.forEach(instance => instance.destroy());
            this.revealElements.length = 0;
        }
    }

    type RevealType = 'lines' | 'block';

    interface RevealOptions {
        type: RevealType;
        element: HTMLElement;
        splitOptions: Required<SplitOptions>;
    }

    class RevealElement {
        private _type: RevealType;
        private _element: HTMLElement;
        private _splitOptions: Required<SplitOptions>;
        private elementCopy?: HTMLElement;
        private intersectionObserverActivate: IntersectionObserver | null = null;
        private intersectionObserverDeactivate: IntersectionObserver | null = null;
        private resizeObserver: ResizeObserver | null = null;
        private isSplit: boolean = false;
        private timeout: number = 0;

        constructor({ type, element, splitOptions }: RevealOptions) {
            this._type = type;
            this._element = element;
            this._splitOptions = splitOptions;
        }

        get type() {
            return this._type;
        }

        get element() {
            return this._element;
        }

        get splitOptions() {
            return this._splitOptions;
        }

        init() {
            this.intersectionObserverActivate = new IntersectionObserver(
                ([entry]) => {
                    if (entry.isIntersecting) {
                        if (this.type === 'lines') {
                            this.intersectionObserverDeactivate = new IntersectionObserver(
                                ([entry]) => {
                                    if (!entry.isIntersecting) {
                                        this.revertLineSplit();
                                    }
                                }
                            );
                            this.intersectionObserverDeactivate.observe(this.element);

                            this.resizeObserver = new ResizeObserver(() => {
                                this.revertLineSplit();
                            });
                            this.resizeObserver.observe(this.element);
                        }

                        this.destroyIntersectionObserverActivate();
                        this.activate();
                    }
                },
                {
                    // See activate() for explanation
                    rootMargin: '50000px 0px 0px 0px',
                }
            );

            this.intersectionObserverActivate.observe(this.element);

            if (this.type === 'lines') {
                this.elementCopy = this.element.cloneNode(true) as HTMLElement;

                // For debugging: Click element to toggle split
                // this.element.addEventListener('click', () => {
                //     if (this.element.dataset.type === 'splitter') {
                //         const elementCopy = this.elementCopy!.cloneNode(true) as HTMLElement;
                //         moveChildNodes(elementCopy, this.element);
                //         moveAttributes(elementCopy, this.element);
                //         this.element.dataset.revealState = this.type;
                //     } else {
                //         split(this.element, this.splitOptions);
                //     }
                // });
            }
        }

        destroy() {
            window.clearTimeout(this.timeout);
            this.destroyResizeObserver();
            this.destroyIntersectionObserverActivate();
            this.destroyIntersectionObserverDeactivate();
        }

        activate() {
            // Verify element is actually visible before revealing.
            // Our large top rootMargin (50000px) can trigger activation for
            // off-screen elements during page navigation (hash anchor links,
            // back button, etc.). We skip animation for elements that aren't
            // truly visible to prevent reveals when scrolling up.
            if (!isPartiallyInViewport(this.element)) {
                this.element.style.setProperty('--duration', '0s');
                this.element.style.setProperty('--delay', '0s');
                this.element.style.setProperty('--stagger', '0s');
                this.element.dataset.revealState = this.type;
                return;
            }
            if (this.type === 'lines') {
                if (!this.isSplit) {
                    this.isSplit = true;
                    this.timeout = window.setTimeout(() => {
                        const fontFamily = window.getComputedStyle(this.element).fontFamily;
                        split(this.element, {
                            ...this.splitOptions,
                            kerningCacheKey: (a: string, b: string) => `${fontFamily}-${a}-${b}`,
                        });
                        this.timeout = window.setTimeout(() => {
                            this.reveal();
                        }, 50);
                    }, 50);
                }
            } else if (this.type === 'block') {
                this.reveal();
            }
        }

        private reveal() {
            const duration = this.element.dataset.revealDuration;
            const delay = this.element.dataset.revealDelay;
            const stagger = this.element.dataset.revealStagger;

            if (duration) {
                this.element.style.setProperty('--duration', duration);
            }
            if (delay) {
                this.element.style.setProperty('--delay', delay);
            }
            if (stagger) {
                this.element.style.setProperty('--stagger', stagger);
            }

            this.element.dataset.revealState = this.type;
        }

        private revertLineSplit() {
            if (this.element.dataset.revealState === 'lines') {
                this.destroyIntersectionObserverDeactivate();
                this.destroyResizeObserver();
                const elementCopy = this.elementCopy!.cloneNode(true) as HTMLElement;
                moveChildNodes(elementCopy, this.element);
                moveAttributes(elementCopy, this.element);
                this.element.dataset.revealState = 'lines';
                this.isSplit = false;
            }
        }

        private destroyResizeObserver() {
            if (this.resizeObserver) {
                this.resizeObserver.disconnect();
                this.resizeObserver = null;
            }
        }

        private destroyIntersectionObserverActivate() {
            if (this.intersectionObserverActivate) {
                this.intersectionObserverActivate.disconnect();
                this.intersectionObserverActivate = null;
            }
        }

        private destroyIntersectionObserverDeactivate() {
            if (this.intersectionObserverDeactivate) {
                this.intersectionObserverDeactivate.disconnect();
                this.intersectionObserverDeactivate = null;
            }
        }
    }

    new RevealController();
</script>
